<template>
  <ion-page class="page-container">
    <!-- Location acquiring overlay -->
    <div v-if="showLocationModal" class="acquire-location-modal">
      <div class="acquire-location-content">
        <ion-spinner name="crescent" class="location-spinner"></ion-spinner>
        <div class="location-modal-message">Acquiring Location...</div>
        <div v-if="locationRequestFailed" class="location-error-message">
          Unable to get your location. Please check your browser permissions.
          <ion-button @click="requestLocationPermission" class="location-retry-button">
            Request Location Access
          </ion-button>
        </div>
      </div>
    </div>

    <!-- Modal dialogs remain unchanged -->

    <ion-modal :is-open="showSetAnchorDialog" @didDismiss="showSetAnchorDialog = false">
      <div class="modal-content enhanced-modal">
        <h3>Set Anchor</h3>
        <div class="slider-label">
          <strong>Range:</strong>
          <span class="slider-value"
            >{{
              anchorState.criticalRange && typeof anchorState.criticalRange.r === "number"
                ? anchorState.criticalRange.r
                : 0
            }}m</span
          >
        </div>
        <ion-range
          v-if="anchorState.criticalRange"
          v-model="anchorState.criticalRange.r"
          :min="10"
          :max="150"
          :step="1"
          ticks="true"
          color="primary"
          class="modal-range modal-range-center"
          style="margin-bottom: 18px; width: 80%"
        />
        <div v-else class="text-danger">Critical range not initialized</div>
        <div class="slider-label">
          <strong>Rode:</strong>
          <span class="slider-value">{{ anchorState.rode.amount }} m</span>
        </div>
        <ion-range
          v-model="anchorState.rode.amount"
          :min="5"
          :max="100"
          :step="1"
          ticks="true"
          color="secondary"
          class="modal-range modal-range-center"
          style="margin-bottom: 18px; width: 80%"
        />
        <div class="slider-label">
          <strong>Bearing:</strong>
          <span class="slider-value"
            >{{ anchorState.anchorDropLocation.originalBearing.degrees || '--'}}°</span
          >
        </div>
        <ion-range
          v-model="anchorState.anchorDropLocation.originalBearing.degrees"
          :min="0"
          :max="360"
          :step="1"
          ticks="true"
          color="primary"
          class="modal-range modal-range-center"
          style="margin-bottom: 18px; width: 80%"
        />
        <div class="modal-actions">
          <IonButton color="primary" @click="handleSetAnchor">Set Anchor</IonButton>
          <IonButton @click="showSetAnchorDialog = false">Cancel</IonButton>
        </div>
      </div>
    </ion-modal>
    <IonModal :is-open="showUpdateDialog" @didDismiss="showUpdateDialog = false">
      <div class="modal-content">
        <h3>Update Drop Location</h3>
        <p>Set the current location as the new anchor drop location?</p>
        <div class="modal-actions">
          <IonButton color="primary" @click="handleUpdateDropLocation"
            >Yes, Update</IonButton
          >
          <IonButton @click="showUpdateDialog = false">Cancel</IonButton>
        </div>
      </div>
    </IonModal>
    <IonModal :is-open="showCancelDialog" @didDismiss="showCancelDialog = false">
      <div class="modal-content">
        <h3>Cancel Anchor</h3>
        <p>Are you sure you want to cancel the anchor?</p>
        <div class="modal-actions">
          <IonButton color="danger" @click="handleCancelAnchor">Yes, Cancel</IonButton>
          <IonButton @click="showCancelDialog = false">No</IonButton>
        </div>
        <div class="modal-actions" style="margin-top: 18px">
          <IonButton color="secondary" @click="showUpdateDropConfirm = true">
            Update Anchor to Current Position
          </IonButton>
        </div>
      </div>
    </IonModal>
    <!-- Confirmation modal for updating anchor drop location -->
    <IonModal
      :is-open="showUpdateDropConfirm"
      @didDismiss="showUpdateDropConfirm = false"
    >
      <div class="modal-content">
        <h3>Update Anchor Drop Location</h3>
        <p>
          Are you sure you want to update the anchor drop location to the current
          position?
        </p>
        <div class="modal-actions">
          <IonButton color="primary" @click="confirmUpdateDropLocation"
            >Yes, Update</IonButton
          >
          <IonButton @click="showUpdateDropConfirm = false">Cancel</IonButton>
        </div>
      </div>
    </IonModal>

    <div class="map-wrapper">
      <!-- <AnchorInfoGrid @drop-anchor="handleDropAnchor" /> -->
      <AnchorInfoGrid />
      <div ref="mapElement" class="openlayers-map"></div>
      <div class="anchor-fab-container">
        <ion-fab-button
          color="secondary"
          @click="showSetAnchorDialog = true"
          class="custom-fab-size"
          :disabled="anchorState?.anchorDeployed"
        >
          <img
            src="/img/anchor2.svg"
            alt="Set Anchor"
            class="custom-icon"
            style="width: 24px; height: 24px"
          />
        </ion-fab-button>
        <ion-fab-button
          color="danger"
          @click="showCancelDialog = true"
          class="custom-fab-size"
          :disabled="!anchorState?.anchorDeployed"
        >
          <ion-icon :icon="chevronUpOutline" size="large" />
        </ion-fab-button>
      </div>
    </div>
    <generic-header title="Anchor"></generic-header>
  </ion-page>
</template>

<script setup>
import { ref, computed, watch, onMounted, onUnmounted } from "vue";
import { storeToRefs } from "pinia";
import { useStateDataStore } from "@/client/stores/stateDataStore";

// Component imports
import AnchorInfoGrid from "@/client/components/AnchorInfoGrid.vue";
import GenericHeader from "@/client/components/GenericHeader.vue";

// Ionic imports
import {
  IonPage, IonModal, IonButton, IonRange, IonSpinner, IonFabButton, IonIcon
} from "@ionic/vue";
import { chevronUpOutline } from "ionicons/icons";

// OpenLayers imports
import Map from "ol/Map";
import View from "ol/View";
import TileLayer from "ol/layer/Tile";
import OSM from "ol/source/OSM";
import VectorLayer from "ol/layer/Vector";
import VectorSource from "ol/source/Vector";
import Feature from "ol/Feature";
import Point from "ol/geom/Point";
import Polygon from "ol/geom/Polygon";
import LineString from "ol/geom/LineString";
import { Style, Fill, Stroke } from "ol/style";
import CircleStyle from "ol/style/Circle"; // Correct import for Circle style
import { fromLonLat } from "ol/proj";
import { defaults as defaultControls } from "ol/control";
import ScaleLine from "ol/control/ScaleLine";

// Component refs
const mapElement = ref(null);
const map = ref(null);

// Store setup
const stateStore = useStateDataStore();
const { state, breadcrumbs } = storeToRefs(stateStore);
const navigationState = computed(() => state.value.navigation);
const anchorState = computed(() => state.value.anchor);

// UI state
const showLocationModal = computed(() => {
  const pos = navigationState.value?.position;
  return !(pos?.latitude?.value && pos?.longitude?.value);
});
const locationRequestFailed = ref(false);
const showSetAnchorDialog = ref(false);
const showUpdateDialog = ref(false);
const showCancelDialog = ref(false);
const showUpdateDropConfirm = ref(false);

// Function to request location permission
const requestLocationPermission = () => {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      () => { locationRequestFailed.value = false; },
      () => { locationRequestFailed.value = true; }
    );
  }
};

// Map layers
const vectorSource = new VectorSource();
const vectorLayer = new VectorLayer({
  source: vectorSource,
  updateWhileAnimating: true,
  updateWhileInteracting: true,
});

// Styles
const boatStyle = new Style({
  image: new CircleStyle({
    // Using the properly imported CircleStyle
    radius: 8,
    fill: new Fill({ color: "#2196f3" }),
    stroke: new Stroke({ color: "#ffffff", width: 3 }),
  }),
  zIndex: 100,
});

const anchorDropStyle = new Style({
  image: new CircleStyle({
    // Using the properly imported CircleStyle
    radius: 8,
    fill: new Fill({ color: "#43a047" }),
    stroke: new Stroke({ color: "#fff", width: 2 }),
  }),
});

const rodeStyle = new Style({
  stroke: new Stroke({
    color: "#FFA500",
    width: 4,
    lineDash: [8, 8],
  }),
});

// Initialize map
const initializeMap = async () => {
  const pos = navigationState.value?.position;
  const center =
    pos?.latitude?.value && pos?.longitude?.value
      ? fromLonLat([pos.longitude.value, pos.latitude.value])
      : fromLonLat([0, 0]);

  map.value = new Map({
    target: mapElement.value,
    layers: [new TileLayer({ source: new OSM() }), vectorLayer],
    view: new View({
      center,
      zoom: getInitialZoom(),
      minZoom: 5,
      maxZoom: 22,
    }),
    controls: defaultControls({ zoom: false }),
  });

  map.value.addControl(new ScaleLine({ units: "metric" }));
};

// Feature updaters
const updateBoatPosition = (pos) => {
  clearFeatures("boat");
  if (!pos?.latitude?.value || !pos?.longitude?.value) return;

  const coords = fromLonLat([pos.longitude.value, pos.latitude.value]);
  const feature = new Feature({
    geometry: new Point(coords),
    type: "boat",
  });
  feature.setStyle(boatStyle);
  vectorSource.addFeature(feature);
};

const updateAnchorFeatures = () => {
  clearFeatures("anchor");
  clearFeatures("circle");
  clearFeatures("rode");

  if (!anchorState.value?.anchorDeployed) return;

  const dropLoc = anchorState.value.anchorDropLocation;
  if (dropLoc?.latitude && dropLoc?.longitude) {
    const dropCoords = fromLonLat([dropLoc.longitude, dropLoc.latitude]);
    const dropFeature = new Feature({
      geometry: new Point(dropCoords),
      type: "anchor",
    });
    dropFeature.setStyle(anchorDropStyle);
    vectorSource.addFeature(dropFeature);

    // Draw anchor circle
    const radius = anchorState.value.criticalRange?.r || 0;
    if (radius > 0) {
      const circlePoints = [];
      for (let i = 0; i <= 360; i += 5) {
        const dest = calculateDestination(dropLoc.latitude, dropLoc.longitude, radius, i);
        circlePoints.push(fromLonLat([dest.longitude, dest.latitude]));
      }
      const circleFeature = new Feature({
        geometry: new Polygon([circlePoints]),
        type: "circle",
      });
      circleFeature.setStyle(
        new Style({
          stroke: new Stroke({ color: "#2196f3", width: 2 }),
          fill: new Fill({ color: "rgba(33,150,243,0.1)" }),
        })
      );
      vectorSource.addFeature(circleFeature);
    }
  }

  // Draw rode line
  const anchorLoc = anchorState.value.anchorLocation?.position;
  const boatPos = navigationState.value?.position;
  if (
    anchorLoc?.latitude &&
    anchorLoc?.longitude &&
    boatPos?.latitude?.value &&
    boatPos?.longitude?.value
  ) {
    const line = new Feature({
      geometry: new LineString([
        fromLonLat([boatPos.longitude.value, boatPos.latitude.value]),
        fromLonLat([anchorLoc.longitude, anchorLoc.latitude]),
      ]),
      type: "rode",
    });
    line.setStyle(rodeStyle);
    vectorSource.addFeature(line);
  }
};

// Helper functions
const clearFeatures = (type) => {
  vectorSource
    .getFeatures()
    .filter((f) => f.get("type") === type)
    .forEach((f) => vectorSource.removeFeature(f));
};

const calculateDestination = (lat, lon, distance, bearing) => {
  const R = 6371000;
  const φ1 = (lat * Math.PI) / 180,
    λ1 = (lon * Math.PI) / 180;
  const θ = (bearing * Math.PI) / 180;
  const δ = distance / R;

  const φ2 = Math.asin(
    Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ)
  );
  const λ2 =
    λ1 +
    Math.atan2(
      Math.sin(θ) * Math.sin(δ) * Math.cos(φ1),
      Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2)
    );

  return {
    latitude: (φ2 * 180) / Math.PI,
    longitude: (λ2 * 180) / Math.PI,
  };
};

const getInitialZoom = () => {
  const savedZoom = localStorage.getItem("anchorMapZoom");
  return savedZoom ? Math.min(Math.max(parseInt(savedZoom), 5), 22) : 15;
};

// Watchers
watch(() => navigationState.value?.position, updateBoatPosition, { deep: true });

watch(() => anchorState.value, updateAnchorFeatures, { deep: true });

watch(
  breadcrumbs,
  (newBreadcrumbs) => {
    clearFeatures("breadcrumb");
    newBreadcrumbs.forEach((crumb, idx) => {
      if (!crumb?.longitude || !crumb?.latitude) return;

      const age = idx / newBreadcrumbs.length;
      const feature = new Feature({
        geometry: new Point(fromLonLat([crumb.longitude, crumb.latitude])),
        type: "breadcrumb",
      });

      feature.setStyle(
        new Style({
          image: new CircleStyle({
            radius: 3,
            fill: new Fill({ color: `rgba(33,150,243,${0.9 - age * 0.8})` }),
            stroke: new Stroke({
              color: `rgba(21,101,192,${0.9 - age * 0.7})`,
              width: 1,
            }),
          }),
        })
      );

      vectorSource.addFeature(feature);
    });
  },
  { deep: true }
);

// Lifecycle
onMounted(() => {
  initializeMap();
  
  // Watch for view changes to save zoom level
  watch(
    () => map.value?.getView(),
    (view) => {
      view?.on("change:resolution", () => {
        localStorage.setItem("anchorMapZoom", view.getZoom());
      });
    }
  );
  
  // Watch for position changes to center map when position becomes available
  watch(
    () => navigationState.value?.position,
    (newPos) => {
      if (map.value && newPos?.latitude?.value && newPos?.longitude?.value) {
        const center = fromLonLat([newPos.longitude.value, newPos.latitude.value]);
        map.value.getView().setCenter(center);
        console.log('[Map] Centered on current position');
      }
    },
    { immediate: true }
  );
});



function handleSetAnchor(){
  const myPos = navigationState.value.position;
  // Set anchorDropLocation properties
  const degrees = anchorState.value.anchorDropLocation.originalBearing.degrees;
  anchorState.value.anchorDropLocation.position.latitude = myPos.latitude;
  anchorState.value.anchorDropLocation.position.longitude = myPos.longitude; 
  anchorState.value.anchorDropLocation.depth = navigationState.value.depth?.belowTransducer ?? null;  
  anchorState.value.anchorDropLocation.time = Date.now();

  anchorState.value.anchorDropLocation.originalBearing.value = degrees * (Math.PI / 180);
  anchorState.value.anchorDropLocation.bearing.value = degrees * (Math.PI / 180);
  anchorState.value.anchorDropLocation.bearing.degrees = degrees;
 
  if (!anchorState.value.anchorLocation) {
    anchorState.value.anchorLocation = {};
  }
  
  // Deep copy the properties
  Object.assign(anchorState.value.anchorLocation, JSON.parse(JSON.stringify(anchorState.value.anchorDropLocation)));
  
  // Set anchorDeployed to true
  anchorState.value.anchorDeployed = true;
  console.log("[handleSetAnchor] anchorState.value:", anchorState.value)
  showSetAnchorDialog.value = false;
}

onUnmounted(() => {
  if (map.value) {
    map.value.setTarget(undefined);
    map.value = null;
  }
  vectorSource.clear();
});
</script>

<style scoped>
.openlayers-map {
  width: 100vw;
  height: 100vh;
  min-height: 0;
}
.map-wrapper {
  width: 100vw;
  height: 100vh;
  min-height: 0;
  position: relative;
  top: 0;
  left: 0;
  z-index: 1;
}
ion-page.page-container {
  width: 100vw;
  height: 100vh;
  min-height: 0;
  position: fixed;
  top: 0;
  left: 0;
  margin: 0;
  padding: 0;
  z-index: 0;
  overflow: hidden;
}
/* Zoom buttons removed - using native OpenLayers pinch-to-zoom functionality */

.anchor-fab-container {
  position: fixed;
  bottom: 80px;
  right: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  z-index: 1000;
}

.custom-fab-size {
  --size: 56px;
  margin: 5px;
}

.custom-icon {
  width: 24px;
  height: 24px;
}

.map-wrapper .ol-scale-line {
  position: absolute !important;
  left: 50% !important;
  bottom: 12px !important;
  transform: translateX(-50%) !important;
  z-index: 1000 !important;
  pointer-events: none !important;
  display: block !important;
  text-align: center !important;
  float: none !important;
  width: auto !important;
}

.map-wrapper .ol-scale-bar,
.map-wrapper .ol-scale-line-inner {
  display: inline-block !important;
  margin: 0 auto !important;
  text-align: center !important;
  float: none !important;
}

.ol-scale-line-inner,
.ol-scale-bar {
  margin: 0 auto;
}

/* Anchor Modal Glassmorphism Styles */
.enhanced-modal {
  border-radius: 28px;
  padding: 44px 24px 32px 24px;
  max-width: 420px;
  margin: 48px auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 2.5px solid rgba(255, 215, 0, 0.12);
  position: relative;
}

.enhanced-modal::before {
  content: "\2693"; /* Unicode anchor icon */
  position: absolute;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 2.3em;
  opacity: 0.85;
  pointer-events: none;
}

.slider-label {
  width: 100%;
  font-weight: 600;
  font-size: 1.13em;
  margin-bottom: 12px;
  padding-left: 10px;
  letter-spacing: 0.5px;
}

.modal-range-center {
  margin: 0 auto 22px auto;
  width: 80%;
}

.modal-actions {
  width: 100%;
  display: flex;
  gap: 18px;
  margin-top: 34px;
}

.modal-actions IonButton {
  /* background: linear-gradient(90deg, #ffd700 60%, #ffe066 100%); */
  color: #12263a;
  border-radius: 12px;
  font-weight: 700;
  border: none;
}

h3 {
  /* color: #ffd700; */
  margin-bottom: 28px;
  letter-spacing: 1px;
  font-size: 2.3em;
  text-align: center;
}

/* Center slider label/value and enlarge modal card */
.acquire-location-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.75);
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
}
.acquire-location-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
.location-spinner {
  margin-bottom: 18px;
}
.location-modal-message {
  color: white;
  font-size: 1.25em;
  font-weight: 500;
  text-align: center;
}

.slider-value {
  font-size: 3em;
  font-weight: bold;
  letter-spacing: 0.5px;
  margin: 2px 0 0 0;
}
</style>
