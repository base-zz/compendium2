/**
 * StateService
 *
 * This service connects to SignalK and other data sources to maintain
 * the unified StateData. It handles the connection, data mapping,
 * and synchronization with the relay system.
 */

import WebSocket from "ws";
import EventEmitter from "events";
import { stateData } from "./StateData.js";
import { signalKAdapterRegistry } from "../../relay/server/adapters/SignalKAdapterRegistry.js";
import fetch from "node-fetch"; // Use node-fetch for HTTP requests
import { extractAISTargetsFromSignalK } from "./extractAISTargets.js";
// import { compare as jsonPatchCompare } from "fast-json-patch";

import pkg from 'fast-json-patch';
const { compare: jsonPatchCompare } = pkg;
class StateService extends EventEmitter {
  _debug(...args) {
    // // console.debug('[StateService]', ...args);
  }

  constructor() {
    super();
    console.log('[StateService] Constructed StateService instance');
    this.config = null;
    this.signalKAdapter = null;
    this.signalKWsUrl = null;
    this.selfMmsi = null;
    // Connection state
    this.connections = {
      signalK: {
        socket: null,
        connected: false,
        reconnectAttempts: 0,
        lastMessage: null,
      },
    };
    this.hasLoggedFirstData = false;
    // Data sources registry
    this.sources = new Map();
    // Update queue for batching
    this.updateQueue = new Map();
    this.updateTimer = null;
    this._aisRefreshTimer = null;
    this._lastFullEmit = 0; // Track last full state emission
    // Define events
    this.EVENTS = {
      CONNECTED: "connected",
      DISCONNECTED: "disconnected",
      ERROR: "error",
      DATA_RECEIVED: "data:received",
      STATE_UPDATED: "state:updated",
      SOURCE_ADDED: "source:added",
      SOURCE_REMOVED: "source:removed",
      STATE_FULL_UPDATE: "state:full-update",
      STATE_PATCH: "state:patch",      
    };
  }

  /**
   * Initialize the service: set config, discover server, connect, set up listeners
   */
  async initialize(config = {}) {
  console.log('[StateService] Initializing with config:', config);
    // Helper: detect Node.js environment
    const isNodeEnv = typeof process !== "undefined" && process.env;

    // Only use process.env in Node; require explicit config in browser
    const signalKBaseUrl =
      config.signalKBaseUrl ||
      (isNodeEnv ? process.env.SIGNALK_URL : undefined);
    if (!signalKBaseUrl) {
      throw new Error(
        "SIGNALK_URL (signalKBaseUrl) must be set in the config or environment."
      );
    }
    const reconnectDelay =
      config.reconnectDelay ||
      (isNodeEnv ? process.env.RECONNECT_DELAY : undefined);
    if (!reconnectDelay) {
      throw new Error(
        "RECONNECT_DELAY must be set in the config or environment."
      );
    }
    const maxReconnectAttempts =
      config.maxReconnectAttempts ||
      (isNodeEnv ? process.env.MAX_RECONNECT_ATTEMPTS : undefined);
    if (!maxReconnectAttempts) {
      throw new Error(
        "MAX_RECONNECT_ATTEMPTS must be set in the environment or config."
      );
    }
    const updateInterval = config.updateInterval || process.env.UPDATE_INTERVAL;
    if (!updateInterval) {
      throw new Error(
        "UPDATE_INTERVAL must be set in the environment or config."
      );
    }
    // Optional: token, debug
    this.config = {
      signalKBaseUrl,
      signalKToken: config.signalKToken || process.env.SIGNALK_TOKEN || null,
      reconnectDelay: parseInt(reconnectDelay, 10),
      maxReconnectAttempts: parseInt(maxReconnectAttempts, 10),
      updateInterval: parseInt(updateInterval, 10),
      debug:
        config.debug !== undefined
          ? config.debug
          : process.env.DEBUG === "true",
      ...config,
    };
    // Set up batch processing before attempting SignalK connection
    this._setupBatchProcessing();

    // Async setup
    await this._discoverSignalKServer();
    await this._connectToSignalK();
    // Fetch the full SignalK state (vessels) once at startup
    try {
      const vesselsUrl = this.config.signalKBaseUrl.replace(/\/$/, '') + '/v1/api/vessels';
      const selfUrl = this.config.signalKBaseUrl.replace(/\/$/, '') + '/v1/api/self';
      console.log('[StateService] Fetching vessels from URL:', vesselsUrl);
      const headers = this.config.signalKToken ? { Authorization: `Bearer ${this.config.signalKToken}` } : {};
      const response = await fetch(vesselsUrl, { headers });
      const selfResponse = await fetch(selfUrl, { headers });
      if (response.ok) {
        const vesselsData = await response.json();
        const selfData = await selfResponse.json();
        const selfMmsi = selfData?.replace('vessels.', '');
        this.selfMmsi = selfMmsi;
        const selfUrl = this.config.signalKBaseUrl.replace(/\/$/, '') + '/v1/api/' + selfData?.replace('vessels.', 'vessels/');
        console.log('[StateService] selfUrl for data extraction:', selfUrl);
        console.log('[StateService] selfMMSI for AIS extraction:', selfMmsi);
        const aisTargets = extractAISTargetsFromSignalK(vesselsData, selfMmsi);
        console.log('[StateService] Output of extractAISTargetsFromSignalK:', JSON.stringify(aisTargets, null, 2));
        stateData.anchor.aisTargets = aisTargets;


        this.startAISPeriodicRefresh(
          async () => {
            // Use the config already available in the instance
            const url = `${this.config.signalKBaseUrl.replace(/\/$/, '')}/v1/api/vessels`;
            const headers = this.config.signalKToken ? { Authorization: `Bearer ${this.config.signalKToken}` } : {};
            const response = await fetch(url, { headers });
            if (!response.ok) throw new Error(`Failed to fetch /vessels: ${response.status}`);
            return { vessels: await response.json() };
          },
          10000 // 30 seconds, or whatever interval you prefer
        );

      } else {
        console.warn('[StateService] Could not fetch full /vessels for AIS extraction:', response.status, response.statusText);
      }
    } catch (err) {
      console.warn('[StateService] Error fetching full /vessels for AIS extraction:', err);
    }
    // this._setupStateListeners && this._setupStateListeners(); // Removed as method does not exist or is not needed
    this._debug("StateService initialized");
    return this;
  }

  /**
   * Update anchor.aisTargets from the latest SignalK vessels data
   * @param {Object} fullSignalKData - Full SignalK document (should include .vessels)
   */
  async updateAISTargetsFromSignalK(fullSignalKData) {
    const aisTargets = extractAISTargetsFromSignalK(fullSignalKData.vessels, this.selfMmsi);
    stateData.anchor.aisTargets = aisTargets;
  }

  // Optionally, add a periodic refresh (every N seconds)
  startAISPeriodicRefresh(fetchSignalKFullState, intervalMs = 10000) {
    if (this._aisRefreshTimer) clearInterval(this._aisRefreshTimer);
    this._aisRefreshTimer = setInterval(async () => {
      try {
        const fullSignalKData = await fetchSignalKFullState();
        await this.updateAISTargetsFromSignalK(fullSignalKData);
      } catch (err) {
        this._debug("AIS periodic refresh error:", err);
      }
    }, intervalMs);
  }

  stopAISPeriodicRefresh() {
    if (this._aisRefreshTimer) clearInterval(this._aisRefreshTimer);
    this._aisRefreshTimer = null;
  }


  /**
   * Discover SignalK server info and select adapter
   */
  async _discoverSignalKServer() {
    // Fetch server info from SignalK HTTP endpoint
    // Fetch discovery JSON from the base SignalK URL (do not append /api/v1/server)
    const infoUrl = this.config.signalKBaseUrl; // should end with /signalk
    const headers = this.config.signalKToken
      ? { Authorization: `Bearer ${this.config.signalKToken}` }
      : {};
    // // // console.log(`[SignalK] Fetching server info from: ${infoUrl}`);
    const response = await fetch(infoUrl, { headers });
    if (!response.ok) {
      console.error(
        `[SignalK] Failed to fetch server info: ${response.status} ${response.statusText}`
      );
      throw new Error(
        `Failed to fetch SignalK server info: ${response.status} ${response.statusText}`
      );
    }
    const discoveryJson = await response.json();
    // console.log('[SignalK] Discovery JSON:', JSON.stringify(discoveryJson, null, 2));
    // Extract endpoints
    const wsUrl = discoveryJson?.endpoints?.v1?.["signalk-ws"];
    if (!wsUrl || typeof wsUrl !== "string" || !wsUrl.startsWith("ws")) {
      console.error("[SignalK] Invalid or missing signalk-ws endpoint:", wsUrl);
      throw new Error(
        "SignalK WebSocket URL (signalk-ws) not found in discovery JSON."
      );
    }
    this.signalKWsUrl = wsUrl;
    // console.log(`[SignalK] Using WebSocket URL: ${this.signalKWsUrl}`);
    // Adapter selection (optional, may use discoveryJson as needed)
    this.signalKAdapter = signalKAdapterRegistry.findAdapter
      ? signalKAdapterRegistry.findAdapter(discoveryJson)
      : null;
    if (!this.signalKAdapter) {
      console.warn(
        "[SignalK] No suitable SignalK adapter found for discovery JSON. Using default."
      );
    }
  }

  /**
   * Connect to the SignalK server
   * @private
   */
  async _connectToSignalK() {
    return new Promise((resolve, reject) => {
      // Build connection URL
      let url = this.signalKWsUrl;
      if (this.config.signalKToken) {
        url += `?token=${this.config.signalKToken}`;
      }
      // Create WebSocket connection
      const socket = new WebSocket(url);
      this.connections.signalK.socket = socket;
      socket.on("open", () => {
        this._debug("Connected to SignalK");
        this.connections.signalK.connected = true;
        this.connections.signalK.reconnectAttempts = 0;
        // Subscribe to all updates
        socket.send(
          JSON.stringify({
            context: "*",
            subscribe: [
              {
                path: "*",
                period: this.config.updateInterval || 1000,
              },
            ],
          })
        );
        this.emit(this.EVENTS.CONNECTED, { source: "signalK" });
        resolve();
      });
      socket.on("message", (data) => {
        let messageStr = data;
        if (Buffer.isBuffer(data)) {
          messageStr = data.toString("utf8");
        }
        this._debug(
          "[DEBUG][StateService] Received SignalK WS message (decoded):",
          messageStr
        );
        this._handleSignalKMessage(data);
      });
      socket.on("error", (error) => {
        this._debug(`SignalK connection error: ${error.message}`);
        this.emit(this.EVENTS.ERROR, {
          source: "signalK",
          error,
          message: error.message,
        });
      });
      socket.on("close", () => {
        this._debug("Disconnected from SignalK");
        this.connections.signalK.connected = false;
        this.emit(this.EVENTS.DISCONNECTED, { source: "signalK" });
        // Attempt to reconnect
        this._reconnectToSignalK();
      });
    });
  } //end _connectToSignalK

  /**
   * Attempt to reconnect to SignalK
   * @private
   */
  _reconnectToSignalK() {
    // Check if we've exceeded max reconnect attempts
    if (
      this.connections.signalK.reconnectAttempts >=
      this.config.maxReconnectAttempts
    ) {
      this._debug("Max reconnect attempts reached, giving up");
      this.emit(this.EVENTS.ERROR, {
        source: "signalK",
        message: "Max reconnect attempts reached",
      });
      return;
    }

    // Increment attempt counter
    this.connections.signalK.reconnectAttempts++;

    // Schedule reconnect
    this._debug(
      `Reconnecting to SignalK (attempt ${this.connections.signalK.reconnectAttempts}/${this.config.maxReconnectAttempts})`
    );
    setTimeout(() => {
      this._connectToSignalK().catch(() => {
        // Error handling is done in _connectToSignalK
      });
    }, this.config.reconnectDelay);
  } //end _reconnectToSignalK

  /**
   * Handle messages from SignalK
   * @private
   */
  async _handleSignalKMessage(data) {
    try {
      const message = JSON.parse(data);
      this.connections.signalK.lastMessage = Date.now();

      if (message.updates) {
        await this._processSignalKDelta(message);
      }
      this.emit(this.EVENTS.DATA_RECEIVED, {
        source: "signalK",
        timestamp: Date.now(),
      });
    } catch (error) {
      this._debug(`Error processing SignalK message: ${error.message}`);
      this.emit(this.EVENTS.ERROR, {
        source: "signalK",
        error,
        message: error.message,
        data,
      });
    }
  } //end _handleSignalKMessage

  /**
   * Process a SignalK delta message
   * @private
   */
  async _processSignalKDelta(delta) {
  // console.log('[StateService] Received delta from SignalK:', JSON.stringify(delta, null, 2));
    if (!delta.updates || !Array.isArray(delta.updates)) {
      return;
    }
    let processedData = delta;
    if (
      this.signalKAdapter &&
      typeof this.signalKAdapter.processMessage === "function"
    ) {
      processedData = this.signalKAdapter.processMessage(delta);
    }
    if (!processedData.updates || !Array.isArray(processedData.updates)) {
      console.warn(
        "[StateService][_processSignalKDelta] No valid updates array after adapter processing:",
        processedData
      );
      return;
    }
    let processedCount = 0;
    for (const update of processedData.updates) {
      const source =
        update.$source || (update.source && update.source.label) || "unknown";
      if (Array.isArray(update.values)) {
        for (const value of update.values) {
          if (value.path) {
            const statePath = this._mapSignalKPathToStatePath(value.path);
            /*
            console.log(
              `[DEBUG][StateService] Mapping SignalK path ${value.path} to state path ${statePath}`
            );
            */
            if (statePath) {
              /*
              console.log(
                `[DEBUG][StateService] Queueing update: statePath=${statePath}, value=${JSON.stringify(
                  value.value
                )}, source=${source}`
              );
              */
              if (value.value !== null && value.value !== undefined && !this.hasLoggedFirstData) {
  console.log(`[StateService] RECEIVED FIRST DATA from SignalK: ${statePath} =`, value.value);
  this.hasLoggedFirstData = true;
}
            this._queueUpdate(statePath, value.value, source);
            } else {
              console.warn(
                "[DEBUG][StateService] No statePath mapping for:",
                value.path
              );
            }
            processedCount++;
            if (processedCount % 10 === 0) {
              await Promise.resolve();
            }
          }
        }
      }
    }
  }

  /**
   * Map SignalK path to StateData path
   * @private
   */
  _mapSignalKPathToStatePath(signalKPath) {
    // This mapping defines how SignalK paths translate to our state structure
    const mappings = {
      // Navigation domain
      "navigation.position": "navigation.position",
      "navigation.courseOverGroundTrue": "navigation.course.cog",
      "navigation.headingMagnetic": "navigation.course.heading",
      "navigation.magneticVariation": "navigation.course.variation",
      "navigation.speedOverGround": "navigation.speed.sog",
      "navigation.speedThroughWater": "navigation.speed.stw",
      "navigation.trip.log": "navigation.trip.log",
      "navigation.trip.lastReset": "navigation.trip.lastReset",

      // Depth
      "environment.depth.belowTransducer": "navigation.depth.belowTransducer",
      "environment.depth.belowKeel": "navigation.depth.belowKeel",
      "environment.depth.belowSurface": "navigation.depth.belowSurface",

      // Wind
      "environment.wind.speedApparent": "navigation.wind.speed",
      "environment.wind.angleApparent": "navigation.wind.angle",
      "environment.wind.directionTrue": "navigation.wind.direction",

      // Environment
      "environment.outside.temperature": "environment.weather.temperature.air",
      "environment.water.temperature": "environment.weather.temperature.water",
      "environment.outside.pressure": "environment.weather.pressure.value",
      "environment.outside.humidity": "environment.weather.humidity",

      // Vessel info
      "vessel.name": "vessel.info.name",
      "vessel.mmsi": "vessel.info.mmsi",
      "vessel.callsignVhf": "vessel.info.callsign",
      "vessel.design.type": "vessel.info.type",
      "vessel.design.length": "vessel.info.length",
      "vessel.design.beam": "vessel.info.beam",
      "vessel.design.draft": "vessel.info.draft",

      // Electrical
      "electrical.batteries": "vessel.systems.electrical.batteries",
      "electrical.sources": "vessel.systems.electrical.sources",

      // Propulsion
      "propulsion": "vessel.systems.propulsion.engines",
      "tanks.fuel": "vessel.systems.propulsion.fuel",

      // Other tanks
      "tanks.freshWater": "vessel.systems.tanks.freshWater",
      "tanks.wasteWater": "vessel.systems.tanks.wasteWater",
      "tanks.blackWater": "vessel.systems.tanks.blackWater",

      // Special handling for position
    };

    // Check for direct mapping
    if (mappings[signalKPath]) {
      return mappings[signalKPath];
    }

    // Recursively check parent paths for mapping (leaf path support)
    const parts = signalKPath.split(".");
    for (let i = parts.length - 1; i > 0; i--) {
      const parentPath = parts.slice(0, i).join(".");
      const suffix = parts.slice(i).join(".");
      if (mappings[parentPath]) {
        return mappings[parentPath] + "." + suffix;
      }
    }

    // Handle nested paths (legacy fallback)
    for (const [skPath, statePath] of Object.entries(mappings)) {
      if (signalKPath.startsWith(skPath + ".")) {
        const suffix = signalKPath.substring(skPath.length);
        return statePath + suffix;
      }
    }

    // Handle special cases
    if (signalKPath.startsWith("navigation.anchor")) {
      // Map anchor paths
      const anchorPath = signalKPath.replace("navigation.anchor.", "anchor.");
      return anchorPath;
    }

    // For paths we don't explicitly map, place in external.signalK domain
    return `external.signalK.${signalKPath.replace(/\./g, "_")}`;
  }

  /**
   * Queue an update to be processed in batch
   * @private
   */
  _queueUpdate(path, value, source) {
    this.updateQueue.set(path, { value, source });
    // console.log(`[DEBUG][StateService] Queued update for path=${path}`);
  }

  /**
   * Set up batch processing of updates
   * @private
   */
  _setupBatchProcessing() {
    if (this.updateTimer) clearInterval(this.updateTimer);
    this.updateTimer = setInterval(() => {
      this._processBatchUpdates();
    }, this.config.updateInterval);
    console.log(
      `[DEBUG][StateService] Batch processing setup with interval ${this.config.updateInterval}ms`
    );
  }

  /**
   * Process all queued updates in a batch
   * @private
   */
  _processBatchUpdates() {
    if (this.updateQueue.size === 0) {
      return;
    }
  
    const updates = {};
    const sources = {};
  
    this.updateQueue.forEach((data, path) => {
      updates[path] = data.value;
      sources[path] = data.source;
    });
  
    // Special handling for lat/lon if both are present
    if (
      updates["navigation.position.latitude"] !== undefined &&
      updates["navigation.position.longitude"] !== undefined &&
      updates["navigation.position.latitude"] !== null &&
      updates["navigation.position.longitude"] !== null
    ) {
      updates["navigation.position"] = {
        latitude: updates["navigation.position.latitude"],
        longitude: updates["navigation.position.longitude"],
      };
      // Clean up individual lat/lon updates
      delete updates["navigation.position.latitude"];
      delete updates["navigation.position.longitude"];
    }
  
    // Anchor domain: sanitize anchorDropLocation assignment
    if (updates["anchor.anchorDropLocation"]) {
      const value = updates["anchor.anchorDropLocation"];
      updates["anchor.anchorDropLocation"] = {
        latitude: value.latitude ?? null,
        longitude: value.longitude ?? null,
        time: value.time ?? null,
        distanceFromCurrentLocation: value.distanceFromCurrentLocation ?? 0,
        distanceFromDropLocation: value.distanceFromDropLocation ?? 0,
        originalBearing: value.originalBearing ?? 0,
      };
    }
  
    // Batch update if there are any updates

    if (Object.keys(updates).length > 0) {
      // Deep copy previous state for diffing
      // const prevState = JSON.parse(JSON.stringify(stateData.state));
      const prevState = stateData.state ? JSON.parse(JSON.stringify(stateData.state)) : {};
      // Apply updates
      const updateResult = stateData.batchUpdate(updates, 'signalK');
      if (updateResult) {
        // Get new state
        const newState = stateData.state;
        
        // Generate JSON patch
        const patches = jsonPatchCompare(prevState, newState);
        
        if (patches.length > 0) {
          this.emit(this.EVENTS.STATE_PATCH, {
            type: 'state:patch',
            data:patches,
            source: 'signalK',
            timestamp: Date.now()
          });
          
          // Emit full state periodically or on significant changes
          if (!this._lastFullEmit || Date.now() - this._lastFullEmit > 30000) {
            this.emit(this.EVENTS.STATE_FULL_UPDATE, {
              type: 'state:full-update',
              data: newState,
              source: 'signalK',
              timestamp: Date.now()
            });
            this._lastFullEmit = Date.now();
          }
        }
      }
      
      // Clear the queue
      this.updateQueue.clear();
    }
  }

/**
 * Register an external data source
 * @param {string} sourceId - Unique identifier for the source
 * @param {Object} initialData - Initial data for this source
 * @param {Function} updateHandler - Function to call when updates are needed
 * @returns {boolean} Success status
 */
  registerExternalSource(sourceId, initialData = {}, updateHandler = null) {
    try {
      // Register the source in state data
      const success = stateData.addExternalSource(sourceId, initialData);

      if (success && updateHandler) {
        // Store the update handler
        this.sources.set(sourceId, { updateHandler });
      }

      this.emit(this.EVENTS.SOURCE_ADDED, {
        sourceId,
        timestamp: Date.now(),
      });

      return success;
    } catch (error) {
      this._debug(`Failed to register external source: ${error.message}`);
      this.emit(this.EVENTS.ERROR, {
        source: "stateService",
        error,
        message: `Failed to register external source: ${sourceId}`,
      });
    }
  }

/**
 * Shutdown the service
 */
shutdown() {
  try {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      return stateData.batchUpdate(fullUpdates, sourceId);
    }
    return true; // or whatever you want to return when there's no timer
  } catch (error) {
    this._debug(`Failed to update from external source: ${error.message}`);
    this.emit(this.EVENTS.ERROR, {
      source: "stateService",
      error,
      message: `Failed to update from external source: ${sourceId}`,
    });
    return false;
  }
}


  /**
   * Remove an external data source
   * @param {string} sourceId - Source identifier to remove
   * @returns {boolean} Success status
   */
  removeExternalSource(sourceId) {
    try {
      // Remove from state data
      const success = stateData.removeExternalSource(sourceId);

      if (success) {
        // Remove from sources map
        this.sources.delete(sourceId);
        this.emit(this.EVENTS.SOURCE_REMOVED, {
          sourceId,
          timestamp: Date.now(),
        });
      }
      return success;
    } catch (error) {
      this._debug(`Failed to remove external source: ${error.message}`);
      this.emit(this.EVENTS.ERROR, {
        source: "stateService",
        error,
        message: `Failed to remove external source: ${sourceId}`,
      });
      return false;
    }
  }
} // <--- Only one closing brace for the class

// Create singleton instance
const stateService = new StateService();

// Utility: fetch the full SignalK state (including vessels)
// Example implementation, adapt as needed for your SignalK server
async function fetchSignalKFullState(signalKBaseUrl, signalKToken) {
  const url = `${signalKBaseUrl}/vessels`;
  const headers = signalKToken ? { Authorization: `Bearer ${signalKToken}` } : {};
  const response = await fetch(url, { headers });
  if (!response.ok) throw new Error(`Failed to fetch /vessels: ${response.status}`);
  return { vessels: await response.json() };
}

export { stateService, StateService, fetchSignalKFullState };
// Print a summary of stateData every 10 seconds for debugging
setInterval(() => {
  if (stateData && stateData.state) {
    // console.dir(stateData.state, { depth: null, colors: true });
  } else {
    // console.info("[StateService] stateData not available");
  }
}, 10000);
